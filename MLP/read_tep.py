import numpy as np
from pathlib import Path

from mutual_information import mutual_information_matrix

class SIS_TEP:
    __base_dir__ = "/home/DATA/datasets/TEP/gillespie_SIS/results"
    __abrv_to_full__ = {
        "er": "erdos-renyi",
        "ba": "barabasi-albert",
        "ws": "watts-strogatz",
        "euc": "euclidean",
        "geo": "geometric",
        "grid": "grid",
        "reg": "regular",
        "sf": "scale-free",
    }

    """
    Class to read a time-evolution profile (TEP) file for the SIS model.
    The TEP file should be a numpy binary file containing a 2D array with the following columns:
    1. Time points
    2. Vertex indices
    The vertex indices should be 1-based.
    The teps generated by generate_tep.jl without optional `--dt` are in this format.

    # Example
    To sample a tep with dt 0.05:
    ```python
    full_tep = SIS_TEP("N100_exact/graph-1-1.npz")
    tep = full_tep.sample(0.05)
    ```
    To sample a tep at time points [0.1, 0.25, 0.3]:
    ```python
    full_tep = SIS_TEP("N100_exact/graph-1-1.npz")
    tep = full_tep.sample([0.1, 0.25, 0.3])
    ```
    """
    def __init__(self, abrv, nb_vertices, i_graph, j_tep, nb_digits_g=2, nb_digits_tep=3):
        self.root = f"{self.__base_dir__}/{self.__abrv_to_full__[abrv]}/N{nb_vertices}"
        self.network_type = abrv
        self.graph_id = f"{i_graph:0{nb_digits_g}d}"
        self.tep_id = f"{j_tep:0{nb_digits_tep}d}"
        self.load_tep()

    def get_tep_location(self):
        return f"{self.root}/tep-{self.network_type}-{self.graph_id}-{self.tep_id}.npz"

    def get_graph_location(self):
        return f"{self.root}/{self.network_type}-{self.graph_id}.npz"
    
    def get_mutual_info_location(self, dt):
        """
        Return the name of the MIM file associated with the TEP.
        """
        return f"{self.root}/mim-{self.network_type}-{self.graph_id}-{self.tep_id}-{dt:.2f}.npz"

    def load_tep(self):
        filename = self.get_tep_location()
        self.data = np.load(filename)
        # time points at which a transition occurs
        self.time_points = self.data[:, 0]
        # vertex indices of the transitions
        self.vertex_indices = self.data[:, 1].astype(int) - 1
        self.N_vertices = max(self.vertex_indices) + 1
        self.max_T = self.time_points[-1]

    def __call__(self, t):
        """
        Returns the state of the system at time t.
        """
        if t < 0:
            raise ValueError("t must be non-negative.")
        idx = np.searchsorted(self.time_points, t, side='right')
        # The state of the system at time t is the parity of the number of times each vertex has transitioned up to time t.
        return np.array([np.count_nonzero(self.vertex_indices[:idx+1] == v) % 2 for v in range(self.N_vertices)])

    def sample_with_dt(self, dt):
        """
        Samples the TEP with a time step dt.
        """
        return np.array([self(t) for t in np.arange(0, self.max_T + dt, dt)])

    def sample_at_ts(self, ts):
        """
        Samples the TEP at time points ts.
        """
        return np.array([self(t) for t in ts])

    def sample(self, t):
        """
        Generate a TEP at time points ts (if ts is an array) or with a time step dt (if t is a number).
        """
        if isinstance(t, float):
            return self.sample_with_dt(t)
        else:
            return self.sample_at_ts(t)

    def load_graph(self):
        """
        Return the adjacency matrix of the graph associated with the TEP.
        """
        return np.load(self.get_graph_location())

    def generate_mutual_info(self, dt, store=True):
        """
        Generate the mutual information matrix for the TEP.
        """
        M = mutual_information_matrix(self.sample_with_dt(dt))
        if store:
            np.savez(self.get_mutual_info_location(dt), M=M)
        return M

    def load_mutual_info(self, dt):
        """
        Load the mutual information matrix for the TEP.
        """
        return np.load(self.get_mutual_info_location(dt))['M']

    def load_or_generate_mutual_info(self, dt):
        """
        Load the mutual information matrix if it exists, otherwise generate it.
        """
        path = Path(self.get_mutual_info_location(dt))
        if path.exists():
            try:
                return np.load(path)['M']
            except:
                pass
        return self.generate_mutual_info(dt)

