import numpy as np
from pathlib import Path

class SIS_TEP:
    __base_dir__ = "/home/DATA/datasets/TEP/gillespie_SIS/results"
    __abrv_to_full__ = {
        "er": "erdos-renyi",
        "ba": "barabasi-albert",
        "ws": "watts-strogatz",
        "euc": "euclidean",
        "geo": "geometric",
        "grid": "grid",
        "reg": "regular",
        "sf": "scale-free",
    }

    """
    Class to read a time-evolution profile (TEP) file for the SIS model.
    The TEP file should be a numpy binary file containing a 2D array with the following columns:
    1. Time points
    2. Vertex indices
    The vertex indices should be 1-based.
    The teps generated by generate_tep.jl without optional `--dt` are in this format.

    # Example
    To sample a tep with dt 0.05:
    ```python
    full_tep = SIS_TEP("N100_exact/graph-1-1.npz")
    tep = full_tep.sample(0.05)
    ```
    To sample a tep at time points [0.1, 0.25, 0.3]:
    ```python
    full_tep = SIS_TEP("N100_exact/graph-1-1.npz")
    tep = full_tep.sample([0.1, 0.25, 0.3])
    ```
    """
    def __init__(self, abrv, nb_vertices, i_graph, j_tep, nb_digits_g=2, nb_digits_tep=3):
        self.filename = f"{self.__base_dir__}/{self.__abrv_to_full__[abrv]}/N{nb_vertices}/tep-{abrv}-{i_graph:0{nb_digits_g}d}-{j_tep:0{nb_digits_tep}d}.npz"
        self.load_file(self.filename)

    def load_file(self, filename):
        self.filename = filename
        self.data = np.load(filename)
        # time points at which a transition occurs
        self.time_points = self.data[:, 0]
        # vertex indices of the transitions
        self.vertex_indices = self.data[:, 1].astype(int) - 1
        self.N_vertices = max(self.vertex_indices) + 1
        self.max_T = self.time_points[-1]

    def __call__(self, t):
        """
        Returns the state of the system at time t.
        """
        if t < 0:
            raise ValueError("t must be non-negative.")
        idx = np.searchsorted(self.time_points, t, side='right')
        # The state of the system at time t is the parity of the number of times each vertex has transitioned up to time t.
        return np.array([np.count_nonzero(self.vertex_indices[:idx+1] == v) % 2 for v in range(self.N_vertices)])

    def sample_with_dt(self, dt):
        """
        Samples the TEP with a time step dt.
        """
        return np.array([self(t) for t in np.arange(0, self.max_T + dt, dt)])

    def sample_at_ts(self, ts):
        """
        Samples the TEP at time points ts.
        """
        return np.array([self(t) for t in ts])

    def sample(self, t):
        """
        Generate a TEP at time points ts (if ts is an array) or with a time step dt (if t is a number).
        """
        if isinstance(t, float):
            return self.sample_with_dt(t)
        else:
            return self.sample_at_ts(t)

    def load_graph(self):
        """
        Return the adjacency matrix of the graph associated with the TEP.
        """
        path = Path(self.filename)
        parts = path.stem.split('-')  # ['tep', 'abrv', 'i_graph', 'j_tep']
        graph_file = f"{parts[1]}-{parts[2]}.npz"
        return np.load(path.parent / graph_file)
