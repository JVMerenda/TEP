# -*- coding: utf-8 -*-
"""Tourist.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WCRq0ltEyJPecPRX7my0kMi-2SO-S6EW
"""

'''
João Vitor B. S. Merenda
This code receive N networks and run the DTW (deterministic tourist walk) algorithm
to generate feature vectors that represent each network. All feature vectors will be put
into a csv file
'''

#Necessary libraries
import networkx as nx
import numpy as np
import random
import concurrent.futures

#At first, we need to extract the net from a .gml file
def network(directory, file):
  G = nx.read_gml(directory+file)
  return G

'''--------------------- Tourist Walk ---------------------'''

#Let's define the memory set
#The tourist can only remember of the last u nodes accessed
#where u is the memory size.
#Trajectory = list of all nodes accessed on the earlier steps
def memory(memory_size, trajectory):
  memoria = []
  if(len(trajectory) <= memory_size):
    memoria = trajectory
  else:
    memoria = trajectory[-memory_size:]
  return memoria

#The tourist has a walking rule.
#In the rule = 'min', the tourist moves toward the nodes which minimize the degree difference
#In the rule = 'max', the tourist moves toward the nodes which maximize the degree difference
#The function receive the actual node, a list of his neighbors, and a walking rule returning the choose one.
def node_choice(G, actual_node, effective_neighborhood, walking_rule):
  neighbors = effective_neighborhood
  degree_actual = G.degree(actual_node)
  diff_degree = []
  #tomando as diferenças
  for node in neighbors:
    diff_degree.append(abs(G.degree(node) - degree_actual))
  #For rule = min
  if(walking_rule == 'min'):
    indexes = [i for i, value in enumerate(diff_degree) if value == min(diff_degree)]
    #If there is only one minimum value, return him
    if(len(indexes) == 1):
      return neighbors[indexes[0]]
    #otherwise verify in the other lists
    else:
      choose_index = random.choice(indexes)
      return neighbors[choose_index]
  #For rule = max
  if(walking_rule == 'max'):
    indexes = [i for i, value in enumerate(diff_degree) if value == max(diff_degree)]
    #If there is only one minimum value, return him
    if(len(indexes) == 1):
      return neighbors[indexes[0]]
    #otherwise verify in the other lists
    else:
      choose_index = random.choice(indexes)
      return neighbors[choose_index]

#Now, let's try find attractors
def find_attractor(trajectory, memory_size):
    n = len(trajectory)
    for start in range(n):
        for length in range(memory_size +1, n-start):
            cycle = trajectory[start:start+length]
            cycle_count = 1
            i = start+length
            while(i + length <= n and trajectory[i:i+length] == cycle):
                cycle_count += 1
                i += length
            if(cycle_count >= 3):
                return length, start

    return 0, n

#Now, the tourist starts walking. Let's make him take a step
#This function retuns the next node which will be visited by the tourist
#This next node cannot be in the tourist's memory
def step(actual_node, memory_vec, walking_rule, G):
  neighbors = list(G.neighbors(actual_node))
  if(len(neighbors) == 0):
    return -1
  #We need verify which neighbors isn't in the tourist's memory
  effective_neighborhood = []
  for i in range(len(neighbors)):
    if(neighbors[i] not in memory_vec):
      effective_neighborhood.append(neighbors[i])

  #if there is a neighbor which is not in memory, the walking stop
  if(len(effective_neighborhood) == 0):
    return -1
  else:
    next_node = node_choice(G, actual_node, effective_neighborhood, walking_rule)
    return next_node


#Below, the tourist walk
def tourist_walk(G, start_node, walking_rule, memory_size):
  #Let's verify if the start node is connected, if he not, the walking stop
  if(len(list(G.neighbors(start_node))) == 0):
    return 0, 0
  trajectory = [start_node]
  actual_node = start_node
  status = 1
  transient = 0
  attractor_period = 0
  while(status != -1):
    #verify if ther is an attractor
    attractor_period, transient = find_attractor(trajectory, memory_size)
    if(attractor_period != 0):
      status = -1
    else:
      memory_vec = memory(memory_size, trajectory)
      next_node = step(actual_node, memory_vec, walking_rule, G)
      if(next_node == -1):
        status = -1
      else:
        trajectory.append(next_node)
        actual_node = next_node
  return transient, attractor_period

#One tourist starts from each network node
#Here, we'll have N trajectories of transient 't' and attractor 'a'
def DTW(G, memory_size, walking_rule):
  transient_vector = []
  attractor_vector = []
  for node in G.nodes():
    transient, attractor_period = tourist_walk(G, node, walking_rule, memory_size)
    transient_vector.append(transient)
    attractor_vector.append(attractor_period)

  return transient_vector, attractor_vector

#The dynamics of the tourist ends here, now, let's to statistics
#------------------- Tourist's Statistics -----------------------

#Let's starts with the histogram
def histogram(trajectory_length, transient_vector, attractor_vector):
  n = len(transient_vector)
  h = 0
  for b in range(0, trajectory_length-1):
    S = 0
    for i in range(n):
      if(transient_vector[i] == b and attractor_vector[i] == trajectory_length - b):
        S = S + 1
    S = S/n
    h = h + S
  return h

#Let's take the feature vector 'phi'
def phi_vec(memory_size, m, transient_vector, attractor_vector):
  feature_vector = []
  for l in range(memory_size + 1, memory_size + m):
    feature_vector.append(histogram(l, transient_vector, attractor_vector))
  return feature_vector

#Let's put all toguether
#Previously works have shown that use many memory sizes and joint the rule 'min' with the rule 'max'
#make the tourist method more porwerful. Then, let's use memories = [1,2,3,4,5], and rule =['min', 'max']
#The resultant feature vector 'psi' will be the concatenation of all of them.

directory = '/home/DATA/datasets/SIS_teps/networks/train_nets/'
G = nx.erdos_renyi_graph(100, 0.1)
memory_sizes = [1,2,3,4,5]
walking_rules = ['min', 'max']
psi = []
m = 5


for memory_size in memory_sizes:
  for walking_rule in walking_rules:
    print(memory_size, walking_rule)
    transient_vector, attractor_vector = DTW(G, memory_size, walking_rule)
    phi = phi_vec(memory_size, m, transient_vector, attractor_vector)
    psi = psi + phi


print(psi)